\documentclass{beamer}
\usetheme{Warsaw}
\usecolortheme{wolverine}

\usepackage{minted, changepage, fontspec}
\setmainfont{Avenir Next}

\title{Making LoopAccessAnalysis more precise}
\author{Ramkumar Ramachandra}
\titlegraphic{\includegraphics[scale=0.20]{llvm-logo}}
\institute{Codasip}
\date{April 16, 2025}

\begin{document}
\begin{frame}
  \titlepage
\end{frame}
\begin{frame}
  LoopAccessAnalysis is a dependency analysis built on ScalarEvolution that is used by:
  \begin{itemize}
    \item LoopVectorize
    \item SLPVectorize
    \item LoopVersioning
    \item LoopDistribute
    \item LoopLoadElimination
  \end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
  Runtime checks are the raison d'Ãªtre of LAA:
  \begin{minted}[fontsize=\footnotesize]{c}
  void saxpy_golden(size_t n, const float a,
    const float *x, float *y) {
  for (size_t iv = 0; iv < n; ++iv)
    y[iv] += a * x[iv];
  }
  \end{minted}

  \vspace{1em}

  Trivally safe to vectorize with \mintinline{c}{float *} replaced with \mintinline{c}{float *restrict}.

  \vspace{1em}

  Non-trivial analysis (determined safe):
  \begin{minted}[fontsize=\footnotesize]{c}
for (size_t iv = 0; iv < n / 2; ++iv)
  x[2 * iv] = x[2 * iv - 1];
  \end{minted}
\end{frame}

\begin{frame}[containsverbatim]
  Trivial variations where LAA falls over:

  \vspace{1em}

  \begin{minted}[fontsize=\footnotesize]{c}
for (size_t iv = 0; iv < n / 2; ++iv)
  x[iv][2 * iv] = x[iv][2 * iv - 1];
  \end{minted}

  \vspace{1em}

  \begin{minted}[fontsize=\footnotesize]{c}
for (size_t iv = 0; iv < n / 2; ++iv)
  x[2 * iv] = x[2 * iv + 1];
  \end{minted}

  \vspace{1em}

  \begin{minted}[fontsize=\footnotesize]{c}
for (size_t iv = 0; iv < n / 7; ++iv)
  x[3 * iv] = x[7 * iv];
  \end{minted}

  \vspace{1em}

  LAA relies on finding array bounds, and reasoning based on simple SCEV expressions. It is not theory-based, and is something that works in practice.
\end{frame}

\begin{frame}[containsverbatim]
  \begin{minted}[fontsize=\footnotesize]{cpp}
struct DepDistanceStrideAndSizeInfo {
    const SCEV *Dist;
    uint64_t MaxStride;
    std::optional<uint64_t> CommonStride;
    bool ShouldRetryWithRuntimeCheck;
    uint64_t TypeByteSize;
    bool AIsWrite;
    bool BIsWrite;
};
  \end{minted}

  \vspace{1em}

  Emphasis: LAA is simple and a lot of the reasoning is quite ad-hoc.
\end{frame}

\begin{frame}[containsverbatim]
  Dependence distance is an SCEV minus:
  \begin{minted}[fontsize=\scriptsize]{cpp}
const SCEV *Dist = SE.getMinusSCEV(Sink, Src);
  \end{minted}
  \vspace{2em}
  Strides of Src and Sink from AddRecs:
  \begin{minted}[fontsize=\scriptsize]{cpp}
std::optional<int64_t>
getStrideFromAddRec(const SCEVAddRecExpr *AR, const Loop *Lp, Type *AccessTy,
                    Value *Ptr, PredicatedScalarEvolution &PSE);
  \end{minted}
  \vspace{2em}
  Stride versioning in case of non-constant stride:
  \begin{minted}[fontsize=\scriptsize]{cpp}
// Stride >= TripCount
if (SE->isKnownPositive(StrideMinusBETaken)) {
  LLVM_DEBUG(
      dbgs() << "LAA: Stride>=TripCount; No point in versioning as the "
                "Stride==1 predicate will imply that the loop executes "
                "at most once.\n");
  return;
}
  \end{minted}
\end{frame}

\begin{frame}[containsverbatim]
  \begin{minted}[fontsize=\scriptsize]{cpp}
// We can only analyze innermost loops.
if (!TheLoop->isInnermost()) {
LLVM_DEBUG(dbgs() << "LAA: loop is not the innermost loop\n");
recordAnalysis("NotInnerMostLoop") << "loop is not the innermost loop";
return false;
}
\end{minted}

  \vspace{1em}

  In contrast, DependenceAnalysis is a complex beast that is theory-based, but has fallen out of maintanence: users are LoopUnrollAndJam and LoopInterchange, which fundamentally need outer-loop analysis.
\end{frame}

\begin{frame}[containsverbatim]
  \begin{adjustwidth}{-1em}{-1em}
    \begin{minted}[fontsize=\scriptsize]{text}
Backward loop carried data dependence.
Dependences:
  Backward:
      %load = load [2 x i32], ptr %gep.A, align 4 ->
      store [2 x i32] %ins, ptr %gep.A.next, align 4

Run-time memory checks:
Grouped accesses:

Non vectorizable stores to invariant address were not found in loop.
SCEV assumptions:
  Equal predicate: %stride == 1

Expressions re-written:
  [PSE] %gep.A = getelementptr inbounds [2 x i32], ptr %A, i64 %mul, i64 1:
    {(4 + %A),+,(8 * %stride)}<%loop>
    --> {(4 + %A),+,8}<%loop>
    \end{minted}
  \end{adjustwidth}
\end{frame}

\begin{frame}[containsverbatim]
  \begin{adjustwidth}{-1em}{-1em}
    \begin{minted}[fontsize=\scriptsize]{text}
Memory dependences are safe with run-time checks
Dependences:
Run-time memory checks:
Check 0:
  Comparing group ([[GRP1:0x[0-9a-f]+]]):
    %gep.dst = getelementptr i32, ptr %dst, i64 %iv.2
  Against group ([[GRP2:0x[0-9a-f]+]]):
    %gep.src = getelementptr inbounds i32, ptr %src, i32 %iv.3
  Grouped accesses:
    Group [[GRP1]]:
      (Low: ((4 * %iv.1) + %dst) High: (804 + (4 * %iv.1) + %dst))
        Member: {((4 * %iv.1) + %dst),+,4}<%inner.loop>
      Group [[GRP2]]:
      (Low: %src High: (804 + %src))
        Member: {%src,+,4}<nuw><%inner.loop>

Non vectorizable stores to invariant address were not found in loop.
SCEV assumptions:
  Equal predicate: %offset == 1

Expressions re-written:
  [PSE] %gep.dst = getelementptr i32, ptr %dst, i64 %iv.2:
    {((4 * %iv.1) + %dst),+,(4 * (sext i32 %offset to i64))<nsw>}<%inner.loop>
    --> {((4 * %iv.1) + %dst),+,4}<%inner.loop>
    \end{minted}
  \end{adjustwidth}
\end{frame}
\end{document}
