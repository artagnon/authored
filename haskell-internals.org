#+LaTeX_CLASS: beamer
#+LaTeX_HEADER: \mode<presentation>
#+LaTeX_HEADER: \usetheme{CambridgeUS}
#+LaTeX_HEADER: \usecolortheme{beaver}
#+LaTeX_HEADER: \setbeameroption{show notes}
#+LaTeX_HEADER: \institute{FOSS.IN/2009}
#+TITLE: Haskell Internals
#+AUTHOR: Ramkumar Ramachandra
#+DATE: 01 December 2009

#+BEGIN_LaTeX
\def\newblock{\hskip .11em plus .33em minus .07em} % Hack to make BibTeX work with LaTeX
#+END_LaTeX

* Part I: Thinking in Haskell
** Project Euler Problem #5
What is the smallest number divisible by each of the numbers 1 to 20?
#+BEGIN_LaTeX
\begin{lstlisting}[language=C]
lcm_store = 1;
for(i = 1; i <= 20; i ++) {
    lcm_store = lcm (lcm_store, i);
}
\end{lstlisting}
#+END_LaTeX
\note{LCM of all numbers from 1 to 20. LCM of 2 numbers can be calculated at a time. So fold!}
** Re-thinking the problem in Haskell
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell, numbers=none, xleftmargin=0em, frame=none]
foldr :: (a -> b -> b) -> b -> [a] -> b
\end{lstlisting}
\begin{lstlisting}[language=Haskell]
euler5 :: (Integral a) => a
euler5 = foldr lcm 1 [1..20]
    where gcd a 0 = a
          gcd a b = gcd b (a `mod` b)
          lcm a b = (a*b) `div` gcd a b
\end{lstlisting}
#+END_LaTeX
** Folds
#+LaTeX: \includegraphics[scale=0.35]{foldl.png}
#+LaTeX: \begin{flushright}\includegraphics[scale=0.35]{foldr.png}\end{flushright}
\note{Most of the time though, you want a right fold, because rather than calling itself immediately, 
what happens is that the function parameter is immediately applied. If for any reason it doesn't 
need its second parameter to generate some of its output, then it's possible that the rest of the
list won't get used. Thus, foldr plays well with laziness and infinite lists. (Obviously in the case
of summing the elements of a list though, this isn't true, so the strict tail recursion works better). 
Catamorphism is a generalization of fold}
** Project Euler Problem #12
What is the first triangle number to have over 500 divisors?
#+BEGIN_LaTeX
\begin{lstlisting}[numbers=none, xleftmargin=0em]
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

\end{lstlisting}
\begin{lstlisting}[numbers=none, xleftmargin=2em, frame=none]
28 = 2^2 + 7^1
(2+1) * (1+1) = 6 divisors
\end{lstlisting}
#+END_LaTeX
** Functional solution
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell, numbers=none, xleftmargin=0em, frame=none]
map :: (a -> b) -> [a] -> [b]
filter :: (a -> Bool) -> [a] -> [a]
\end{lstlisting}
\begin{lstlisting}[language=Haskell]
euler12 :: (Integral a) => a
euler12 = head $ filter ((> 500) . n_divisors) triangleSeries
    where triangleSeries = [div (n * (n + 1)) 2 | n <- [1..]]
          n_divisors n = product . map ((+1) . length) . primeGroups $ n
	  primeGroups = group . (primeFactors n) . filterPrimes
          filterPrimes n = filter (\x -> n `mod` x == 0) primes
\end{lstlisting}
#+END_LaTeX
\note{An introduction to top-down programming, graph reduction, filters and maps}
* Part II: A peek into GHC
** Core language
*** Local defintions
*** where -$>$ let/ letrec
*** case for pattern matching
*** Local function definitions (lambda abstractions)
*** Structured data types
#+BEGIN_LaTeX
\begin{lstlisting}[xleftmargin=0em, numbers=none]
square x = x * x ;
main = square (square 3)
\end{lstlisting}
#+END_LaTeX
\note{Evaluating the Core language; building the Core language involves boring grammar parsing. 
where is a clause. let and letrec are expressions. 
lambda abstractions are removed by lambda lifter.}
** Graph reduction (Template compiler)
#+LaTeX: \begin{center}\includegraphics[scale=0.5]{graph-reduction.png}\end{center}
** Laziness
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
euler14 :: Integer
-- Stack overflow!
euler14 = foldl1 (\ x y -> if chain_len x < chain_len y then y else x) l
    where chain_len = length . collatz_chain
          l = [2, 3 .. 999999]

collatz_chain :: Integer -> [Integer]
collatz_chain 1 = [1 ]
collatz_chain n | even n = n : (collatz_chain $ div n 2)
                | otherwise = n : (collatz_chain $ 3 * n + 1)
\end{lstlisting}
\begin{lstlisting}[language=Haskell, numbers=none, xleftmargin=0em]
euler14 = fst . maximumBy (\a b -> compare (snd a) (snd b)) $ collatzip
    where collatzip = zip l (map length $ map collatz_chain l)
\end{lstlisting}
#+END_LaTeX
\note{Lazy evaluation is a modification of outermost-first evaluation which ensures that if a parameter
to a function occurs more than once in the body, then any work done evaluating it is shared between the copies. 
Fortunately, whatever reduction sequence we choose, we will always get the same answer (that is, normal form). 
Inefficient because of the recursive traversal of the template.}
** A peek into more optimizations
*** Lambda lifter
*** G-Machine compiler
*** TIM compiler
*** Parallel G-machine compiler
   \note{Before running the program, translate each supercombinator body to a sequence of instructions which,
   when executed, will construct an instance of the supercombinator body}
* Conclusion
** References
#+BEGIN_LaTeX
\nocite{*}
\bibliographystyle{acm}
\bibliography{haskell-internals}
#+END_LaTeX
** Contact information
#+BEGIN_LaTeX
Ramkumar Ramachandra\\
artagnon@gmail.com\\
\url{http://artagnon.com}\\
Indian Institute of Technology, Kharagpur\\
Presentation source available on \url{http://github.com/artagnon/foss.in}
#+END_LaTeX
